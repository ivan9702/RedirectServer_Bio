#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('redirectserver:server');
var http = require('http');
const https = require('https');
const axios = require('axios');

const {BioserverId} = require('./../models/bioserverId');
const {UserFP} = require('./../models/userFP');
const {sslOptions} = require('./../sslLicense');
const {EventLog} = require('./../models/eventLog');
const {config} = require('./../readConfig');
const {Statistics} = require('./../models/statistics');

/**
 * Global variables.
 */

Date.prototype.yyyymmdd = function() {
  var yyyy = this.getFullYear().toString();
  var mm = (this.getMonth()+1).toString(); // getMonth() is zero-based
  var dd  = this.getDate().toString();

  return yyyy + '-' + (mm[1]?mm:"0"+mm[0]) + '-' + (dd[1]?dd:"0"+dd[0]);
};

Date.prototype.yyyymm = function() {
  var yyyy = this.getFullYear().toString();
  var mm = (this.getMonth()+1).toString(); // getMonth() is zero-based
  //var dd  = this.getDate().toString();

  return yyyy + '-' + (mm[1]?mm:"0"+mm[0]);
};

Array.prototype.shiftRight = function (offset) {
  if (offset >= this.length) {
    offset = this.length;
  }
  this.splice(this.length - offset, offset);
  this.splice(0, 0, ...new Array(offset).fill(0));
  return this;
}

numberWithCommas = function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};

let get7days = function(today){
  let sevenDays = [];
  for(let i = 0; i < 7; i++){
    let dateToPush = new Date(today);
    dateToPush.setDate(today.getDate() - i);
    dateToPush = dateToPush.yyyymmdd();
    sevenDays.push(dateToPush);
  }
  return sevenDays;
};

// a and b are javascript Date objects
function dateDiffInDays(a, b) {
  let _MS_PER_DAY = 1000 * 60 * 60 * 24;
  // Discard the time and time-zone information.
  let utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  let utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

  return Math.floor((utc2 - utc1) / _MS_PER_DAY);
}

RedirectData = {
  lastUserId: 1,
  lastBSId: 1,
  bioservers: []
};

BrowserInfo = {
  todayDate: new Date(),
  totalAPICallAmount: 0,
  todayAPICallAmount: 0,
  totalFPAmount: 0,
  databaseLink: '',
  totalErrCallAmount: 0,
  todayErrCallAmount: 0,
  totalIdentifyAmount: 0,
  totalVerifyAmount: 0,
  totalEnrollAmount: 0,
  totalDeleteAmount: 0,
  today200Amount: 0,
  today403Amount: 0,
  today404Amount: 0,
  today406Amount: 0,
  today501Amount: 0,
  allMonths: [],
  sevenDays: [],
  weeklyInfo: null,
  version: 'v1.1.0'
};

function resetTodaysStatistics() {
  BrowserInfo.todayAPICallAmount = 0;
  BrowserInfo.todayErrCallAmount = 0;
  BrowserInfo.today200Amount = 0;
  BrowserInfo.today403Amount = 0;
  BrowserInfo.today404Amount = 0;
  BrowserInfo.today406Amount = 0;
  BrowserInfo.today501Amount = 0;
}

function resetWeeklyStatistics() {
  BrowserInfo.weeklyInfo = new Array(5);
  for (let i = 0; i < BrowserInfo.weeklyInfo.length; i++) {
    BrowserInfo.weeklyInfo[i] = new Array(7).fill(0);
  }
}

function updateWeeklyStatistics(offset) {
  BrowserInfo.weeklyInfo.forEach((arr) => {
    arr.shiftRight(offset);
  });
}

function commonUpdateProcedure(date1, date2) {
  resetTodaysStatistics();
  const dayDiff = dateDiffInDays(date1, date2);
  if (6 < dayDiff) {
    resetWeeklyStatistics();
  } else {
    updateWeeklyStatistics(dayDiff);
  }
}

updateTodaysStatistics = function (reqPath, resCode) {
  BrowserInfo.todayAPICallAmount++;
  switch (reqPath) {
    case "/enroll":
      BrowserInfo.weeklyInfo[0][0]++;
      break;
    case "/delete":
      BrowserInfo.weeklyInfo[1][0]++;
      break;
    case "/verify":
      BrowserInfo.weeklyInfo[2][0]++;
      break;
    case "/identify":
      BrowserInfo.weeklyInfo[3][0]++;
      break;
  }
  switch (resCode) {
    case 20001:
    case 20002:
    case 20003:
    case 20004:
    case 20005:
    case 20006:
      BrowserInfo.today200Amount++;
      break;
    case 40301:
    case 40302:
      BrowserInfo.today403Amount++;
      break;
    case 40401:
    case 40402:
    case 40403:
    case 40404:
    case 40405:
      BrowserInfo.today404Amount++;
      break;
    case 40601:
    case 40602:
    case 40603:
    case 40604:
    case 40605:
    case 40606:
      BrowserInfo.today406Amount++;
      break;
    case 50101:
    case 50102:
    case 50103:
      BrowserInfo.today501Amount++;
      break;
  }
  if (resCode > 40000) {
    BrowserInfo.weeklyInfo[4][0]++;
    BrowserInfo.todayErrCallAmount++;
  }
}

updateStatistics = async function(option) {
  let existFlag = 0;
  if (option) {
    existFlag = 1;
    commonUpdateProcedure(BrowserInfo.todayDate, option.eventTime);
    updateTodaysStatistics(option.reqPath, option.resCode);
  } else {
    // start server
    const todayDate = new Date();
    todayDate.setHours(0,0,0,0);
    const storedData = await Statistics.find({});
    if (1 === storedData.length) {
      existFlag = 1;
      BrowserInfo = Object.assign({}, storedData[0].browserInfo);
      if (BrowserInfo.todayDate.yyyymmdd() !== todayDate.yyyymmdd()) {
        commonUpdateProcedure(BrowserInfo.todayDate, todayDate);
      }
    } else {
      // clean Redirect server
      resetWeeklyStatistics();
    }
  }
  BrowserInfo.todayDate = new Date();
  BrowserInfo.todayDate.setHours(0,0,0,0);
  BrowserInfo.sevenDays = get7days(BrowserInfo.todayDate);
  // console.log(BrowserInfo);
  try {
    const updateTime = option ? option.eventTime : new Date();
    const infoObj = Object.assign({}, BrowserInfo);
    if (1 === existFlag) {
      await Statistics.findOneAndUpdate({index: 1}, {
        $set: {
          browserInfo: infoObj,
          updateTime: updateTime.toUTCString()
        }
      });
    } else {
      const updatedData = new Statistics({
        index: 1,
        browserInfo: infoObj,
        updateTime: updateTime.toUTCString()
      });
      await updatedData.save();
    }
  } catch (e) {
    console.log(e);
  }
}

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Create HTTPS server.
 */

const httpsServer = https.createServer(sslOptions, app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

const httpsPort = process.env.MYHTTPSPORT || 8443;
httpsServer.listen(httpsPort);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

async function setupBioserver() {
  let errorFlag = 0;
  try {
    const bioservers = await BioserverId.find({});
    errorFlag = 1;
    if (0 === bioservers.length) {
      errorFlag = 2;
      const agent = new https.Agent({rejectUnauthorized: false});
      const getServerInfoURL = config.defaultBioserverIP + '/api/getServerInfo';
      const response = await axios.get(getServerInfoURL, {httpsAgent: agent});
      errorFlag = 3;
      if (20005 === response.data.code) {
        const newBioserver = new BioserverId({
          bsIP: config.defaultBioserverIP,
          bsId: 1,
          count: 0,
          version: response.data.version,
          updated_at: new Date().toUTCString()
        });
        await newBioserver.save();
        RedirectData.bioservers.push({
          bsIP: config.defaultBioserverIP,
          bsId: 1,
          count: 0,
          version: response.data.version
        });
        RedirectData.lastBSId++;
      } else {
        throw new Error('res code error');
      }
    } else {
      bioservers.sort((a, b) => {
        return b.bsId - a.bsId;
      });
      RedirectData.lastBSId = bioservers[0].bsId + 1;
      console.log('lastBSId: ' + RedirectData.lastBSId);
      bioservers.forEach((bioserver) => {
        RedirectData.bioservers.push({
          bsIP: bioserver.bsIP,
          bsId: bioserver.bsId,
          count: bioserver.count,
          version: bioserver.version
        });
      });
      console.log('RedirectData.bioservers: ' + JSON.stringify(RedirectData.bioservers, null, 2));
      const lastUser = await UserFP.find({}, null, {sort: {userId: -1}, limit: 1});
      if (1 === lastUser.length) {
        RedirectData.lastUserId = lastUser[0].userId + 1;
        console.log('lastUserId: ' + RedirectData.lastUserId);
      }
    }
  } catch (e) {
    if ('res code error' === e.message) {
      console.log('response code error');
    } else if (2 === errorFlag) {
      console.log('Could not connect to the new Bioserver.');
      console.log(e.message);
    } else {
      console.log('May be Some Error on MongoDB.');
    }
  }
}

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);

  setupBioserver();
  updateStatistics();
}
